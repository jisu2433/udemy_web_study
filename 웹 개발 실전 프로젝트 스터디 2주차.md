# 웹 개발 실전 프로젝트 스터디 2주차

## 11. DOM이란?

### 11-1. DOM 개요

**웹 페이지를 구성하는 JavaScript 객체들의 집합**

- 문서 객체에는 모든 정보가 담겨있음
- 메서드나 특성을 이용해 정보 변경 가능

### 11-2. Selecting

`getElementById()`

- 일치하는 `id`를 찾음, 없으면 `undefined`

```jsx
const image = document.getElementById("unicorn");
const heading = document.getElementById("mainheading");
```

`getElementsByTagName()`

- 일치하는 태그를 모두 찾음
- 배열 같은 객체인 HTML 집합을 반환

`getElementsByClassName()`

- 일치하는 클래스를 모두 찾음
- 배열 같은 객체인 HTML 집합을 반환

`querySelector()`

- 어떤 것이든 찾음
- 첫 번째로 일치하는 값을 반환
- JavaScript 객체 반환

`querySelectorAll()`

- 일치하는 모든 요소 반환

```jsx
const doneTodos = document.querySelectorAll(".done");
const checkbox = document.querySelector("input:nth-of-type(2)");

// class가 done인 요소 다 찾음
// 두번째 input 찾음
```

### 11-3. innerHTML, textContent, & innerText

`textContent`

- 요소 안에 있는 모든 요소를 반환

`innerText`

- 텍스트만 반환

`innerHTML`

- 특정 요소에 포함된 마크업의 전체 내용 출력
- HTML 자체에서 직접 가져오게 된다.

```jsx
document.querySelector('span').innerText = "Disgusting”
```

### 11-4. 속성(Attributes)

`getAttribute()`

- 속성 나타냄

`setAttribute()`

- 속성 변경 가능

```jsx
let image = document.querySelector("img");
image.setAttribute(
  "src",
  "[https://devsprouthosting.com/images/chicken.jpg](https://devsprouthosting.com/images/chicken.jpg)"
);
image.setAttribute("alt", "chicken");
```

### 11-5. 스타일 변경하기

```jsx
const div = document.querySelector("#container");
div.style.textAlign = "center";
const image = document.querySelector("img");
image.style.width = "150px";
image.style.borderRadius = "50%";
```

```jsx
1. 첫 풀이
const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];

const spans = document.querySelectorAll('h1 span');
spans.forEach((item, index) => {
item.style.color = colors[index];
})

2. 두번째 풀이
const spans = document.querySelectorAll('h1 span');
for(let i=0; i<colors.length; i++){
    spans[i].style.color = colors[i];
}
```

### 11-6. ClassList

- 요소에 현재 class 적용

```jsx
const li = document.querySelectorAll("li");
for (let i of li) {
  i.classList.toggle("highlight");
}
```

### 11-7. 계층 이동

`.parentElement`

- 위로 이동

`.childElementCount`

- 자식 요소의 개수를 알려줌

`.previousElementSibling`

- 이전 형제 요소

`.nextElementSibling`

- 다음 형제 요소

### 11-8. 새로운 요소 만들기, 제거하기

`document.createElement(만들고 싶은 요소의 타입)`

`document.body.appendChild()`

- body 마지막에 추가

```jsx
const container = document.querySelector("#container");
for (let i = 0; i < 100; i++) {
  let btn = document.createElement("button");
  btn.innerText = "Hey!";
  container.appendChild(btn);
}
```

`removeChild()`

제거하려는 요소의 부모에 메서드를 호출해야 함

`remove()`

부모나 자식 신경 No~

## 12. DOM 이벤트

### 12-1. 인라인 이벤트

- 추천하지 않는 방법

```jsx
<h1 onClick="console.log('boo')">Inline Events Suck...</h1>
<button id="btn" onClick="console.log('clicked')">Click Me</button>
```

### 12-2. OnClick 속성

- 추천하는 방법

```jsx
const btn = document.querySelector("button");

btn.onclick = function () {
  console.log("You clicked me!");
};
```

- 재사용 가능
- 여러 개 적용 가능

### 12-3. addEventListener

`addEventListener(’이벤트 종류’, 콜백)`

- 어떤 이벤트도 전달 가능
- 하나의 객체에 여러 개의 이벤트 추가 가능

```jsx
const firstBtn = document.querySelector("#hello");
const secondBtn = document.querySelector("#goodbye");

firstBtn.addEventListener("click", () => {
  console.log("hello");
});

secondBtn.addEventListener("click", () => {
  console.log("goodbye");
});
```

### 12-4. 이벤트와 this 키워드

```jsx
const buttons = document.querySelectorAll("button");

for (let button of buttons) {
  button.addEventListener("click", colorize);
}

const divs = document.querySelectorAll("div");

for (let div of divs) {
  div.addEventListener("click", colorize);
}

function colorize() {
  this.style.backgroundColor = makeRandColor();
  this.style.color = makeRandColor();
}
//this로 코드를 중복할 필요 없이 다른 이벤트에 추가
```

### 12-5. 키보드 이벤트와 이벤트 객체

```jsx
const input = document.querySelector("input");
input.addEventListener("keydown", (e) => {
  console.log(e.key); // 입력 값, 글자
  console.log(e.code); // 키보드에서의 실제 위치
});
```

### 12-6. 폼 이벤트와 PreventDefault

```jsx
const tweetForm = document.querySelector("#tweetForm");
const tweetsContainer = document.querySelector("#tweets");

tweetForm.addEventListener("submit", (e) => {
  e.preventDefault(); //기본 동작 안하게 멈춤
  //const usernameInput = document.querySelectorAll('input')[0];
  //const tweetInput = document.querySelectorAll('input')[1];
  const usernameInput = tweetForm.elements.username;
  const tweetInput = tweetForm.elements.tweet;
  addTweet(usernameInput.value, tweetInput.value);
  usernameInput.value = "";
  tweetInput.value = "";
});

const addTweet = (username, tweet) => {
  const newTweet = document.createElement("li");
  const bTag = document.createElement("b");
  bTag.append(username);
  newTweet.append(bTag);
  newTweet.append(`- ${tweet}`);
  tweetsContainer.append(newTweet);
};
```

### 12-7. 입력과 변경 이벤트

입력 이벤트

- 타이핑하면 작동

변경 이벤트

- 변경 이벤트는 입력을 블러 아웃(blur out) 할 때만 작동
- 입력을 떠날 때마다 업데이트 (타이핑 새로 한 후)

```jsx
const input = document.querySelector("input");
const h1 = document.querySelector("h1");

input.addEventListener("input", (e) => {
  h1.innerText = `Welcome, ${input.value}`;
  if (input.value === "") {
    h1.innerText = "Enter Your Username";
  }
});
```

### 12-8. 이벤트 버블링

- 버블링 단계는 이벤트가 하위 요소에서 상위 요소 방향으로 전파하는 것

```jsx
<section onclick="alert('section clicked')">
  <p onclick="alert('paragraph clicked')">
    I am a paragraph;
    <button onclick="alert('button clicked')">Click</button>
  </p>
</section>
```

`**button` 클릭 시 `p`와 `section` 이벤트도 실행\*\*

**`stopPropagation()`**

- `stopPropagation` 메서드는 이벤트가 버블링 단계와 캡처링 단계에서 전파되는 것을 방지

```jsx
<!DOCTYPE html>
<html>
<body>
    <div id="div">
        div입니다.
        <p id="p">
            p입니다.
            <a href="https://www.naver.com" id="a">NAVER</a>
        </p>
    </div>
    <script>
    const div = document.getElementById('div');
    const p = document.getElementById('p');
    const a = document.getElementById('a');

    div.addEventListener('click', () => {
        console.log('div 클릭');
    });

    p.addEventListener('click', () => {
        event.stopPropagation(); // 이벤트 전파 중지
        console.log('이벤트 전파 중지의 p 클릭');
    });

    p.addEventListener('click', () => {
        console.log('p 클릭');
    });

    a.addEventListener('click', () => {
        console.log('a 클릭');
    });
    </script>
</body>
</html>
```

`stopPropagation` 메서드가 이벤트 전파를 중지하면서 `p` 요소를 클릭 시 `p`이벤트만 실행하고 상위 요소인 `div` 이벤트로 이벤트 전파가 일어나지 않음

### 12-9. 이벤트 위임

- 상위 DOM 요소에 이벤트 핸들러 등록
- 이벤트 수신기가 추가된 시점에 페이지에 없었던 요소를 다루는 상황에서 편리

```jsx
tweetsContainer.addEventListener('click', function(e) }
	e.target.nodeName === 'LI' && e.target.remove();
})
// LI면 삭제
```

## 13. 비동기식 JavaScript

### 13-1. 콜 스택(Call Stack)

**스택**은 컴퓨터 과학의 기본 데이터 구조

- 후입선출(LIFO) 데이터 구조

**콜 스택이란 JavaScript가 사용하는 매커니즘**

- 여러 함수를 호출하는 스크립트에서 해당 위치를 추적

1. 스크립트가 함수를 호출하면 해석기는 콜 스택에 추가
2. 실제 그 함수를 수행하기 시작
3. 첫 번째 함수가 호출한 다른 함수도 콜 스택에 추가되어 호출되면 실행
4. 현재 함수가 완료되면 해석기는 콜 스택에서 함수를 제거
5. 마지막 코드 목록의 멈춘 곳에서 계속 실행

### 13-2. WebAPI와 단일 스레드

**WebAPI**

- JavaScript에서 호출하여 브라우저로 전달하는 방법
- 콜 스택이 Web API 함수를 인식하고 브라우저에 전달

전체 메커니즘

1. 브라우저에 함수가 있고 JavaScript를 위해 실행
2. 바로 실행하지 않고 실행되는 함수를 전달하는 콜백

```jsx
console.log("I print first!");
setTimeout(() => {
  console.log("I print after 3 seconds");
}, 3000);
console.log("I print second!");
```

### 13-3. Callback이라는 지옥

JavaScript는 최대 한 번에 한 줄의 코드만 실행하기 때문에 직접 수행해야 할 작업을 추가해야 함

종속적인 작업이 있다면 코드에 중첩이 많이 생기기 때문에 **콜백지옥**이라고 부름

```jsx
searchMoviesAPI(
  "amadeus",
  () => {
    saveToMyDB(
      movies,
      () => {
        //if it works, run this:
      },
      () => {
        //if it doesn't work, run this:
      }
    );
  },
  () => {
    //if API is down, or request failed
  }
);
```

그래서 **promise**가 필요함

**Promise** 는 하나의 객체

- 최종 값이나 작동 여부에 대한 약속

```jsx
fakeRequestPromise('yelp.com/api/coffee/page1')
.then(() => {
	console.log("It worked!!!!!") // 콜백 넣기 promise가 resolve
	fakeRequestPromise('yelp.com/api/coffee/page2')
		.then(() => {
			console.log("It worked 2!!!!!")
		})
		.catch(() => {
			console.log("Oh no, error!!!!") //콜백 넣기 promise가 reject
		})
.catch(() => {
	console.log("Oh no, error!!!!") //콜백 넣기 promise가 reject
})
```

### 13-4. Promise의 마법

```jsx
fakeRequestPromise('yelp.com/api/coffee/page1')
	.then(() => {
		console.log("It worked!!! (page1)")
		return fakeRequestPromise('yelp.com/api/coffee/page2')
	})
	.then(() => {
		console.log("It worked!!! (page2)")
		return fakeRequestPromise('yelp.com/api/coffee/page3')
})
.then(() => {
	console.log("It worked!!! (page3)")
})
.catch(() => {
	console.log("Oh no, failed!!!")
//콜백 지옥과 다르게 코드 중복이 줄어든다.
```

### 13-5. 자신만의 Promises 만들기

```jsx
const delayedColorChange = (color, delay) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      document.body.style.backgroundColor = color;
      resolve();
    }, delay);
  });
};

delayedColorChange("red", 1000)
  .then(() => delayedColorChange("orange", 1000))
  .then(() => delayedColorChange("green", 1000))
  .then(() => delayedColorChange("blue", 1000));
```

### 13-6. 비동기 키워드

깔끔한 코드 만들 수 있음

**async**

- 함수를 선언할 때
- 자동으로 Promise 반환

```jsx
const login = async (username, password) => {
  if (!username || !password) throw "Missing Credentials";
  if (!password === "danah") return "Welcome!";
  throw "Invalid Password";
};

login("asdasd")
  .then((msg) => {
    console.log("Logged in");
    console.log(msg);
  })
  .catch((err) => {
    console.log("Error!");
    console.log(err);
  });
```

### 13-7. 대기 키워드

**await**

- 비동기 함수의 실행을 일시 정지

```jsx
async function rainbow() {
  await delayedColorChange("red", 1000);
  await delayedColorChange("orange", 1000);
}

rainbow().then(() => console.log("End of rainbow!"));

async function printRainbow() {
  await rainbow();
  console.log("End of rainbow!");
}
```

### 13-8. 비동기 함수의 오류 처리하기

````jsx
async function makeTwoRequests() {
	try {
		let data1 = await fakeRequest('/page1');
		let data2 = await fakeRequest('/page2');
		console.log(data1);
	} catch(e){
		console.log("caught an error!")
		console.log("error is:", e)
    ```
````
